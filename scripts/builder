#!/usr/bin/env bash
set -e

orders="${1}"
app_root="${HOME}/app"
cache_root="${BUILDPACK_CACHE_DIR:-${HOME}/cache/app}"
buildpack_root="${HOME}/build/buildpacks"

buildpacks=($buildpack_root/*)
selected_buildpack=

source /usr/bin/tools

# start: heroku buildpack hack (some buildpacks create "temp" /app dir)
sudo bash -c "mkdir -p /app && chown ${STARPHLEET_APP_USER}:${STARPHLEET_APP_USER} /app"
# end: heroku buildpack hack

mkdir -p $cache_root
mkdir -p $app_root/.profile.d

# This is to get a custom buildpack. Probably should use profile.d though
[ -f "$app_root/.env" ] && . "$app_root/.env"

if [ -n "$BUILDPACK_URL" ]; then
  echo "       Fetching custom buildpack"
  buildpack="$buildpack_root/custom"
  rm -rf "$buildpack"
  #mod here to allow #branch syntax
  sudo starphleet-git-synch "$BUILDPACK_URL" "$buildpack"
  selected_buildpack="$buildpack"
  buildpack_name=$($buildpack/bin/detect "$app_root") && selected_buildpack=$buildpack
else
  for buildpack in "${buildpacks[@]}"; do
    if [ -x $buildpack/bin/detect ]; then
      buildpack_name=$($buildpack/bin/detect "$app_root") && selected_buildpack=$buildpack && break
    fi
  done
fi

if [ -n "$selected_buildpack" ]; then
  echo "       $buildpack_name app detected"
else
  echo "       Unable to select a buildpack"
  exit 1
fi

# generate a random request id used by buildpack instrumentation
export REQUEST_ID=$(openssl rand -base64 32)

# the build pack writes to our buildpack dir, and the build pack runs NOT AS ROOT
sudo chown -R ${STARPHLEET_APP_USER}:${STARPHLEET_APP_USER} ${buildpack_root}
if dev_mode ; then
  rm -rf ${app_root}/.heroku
fi
$selected_buildpack/bin/compile "$app_root" "$cache_root"

# start: heroku buildpack hack (some buildpacks create "temp" /app dir)
sudo rm -rf "/app"
sudo ln -s "${app_root}" "/app"
# end: heroku buildpack hack

echo "-----> Discovering process types"

$selected_buildpack/bin/release "$app_root" > "$app_root/.release"

if [[ -f "$app_root/Procfile" ]]; then
  types=$(ruby -e "require 'yaml';puts YAML.load_file('$app_root/Procfile').keys().join(', ')")
  echo "       Procfile declares types -> $types"
fi
default_types=$(ruby -e "require 'yaml';puts (YAML.load_file('$app_root/.release')['default_process_types'] || {}).keys().join(', ')")
[[ $default_types ]] && echo "       Default process types for $buildpack_name -> $default_types"

sudo mkdir -p $app_root/.profile.d
ruby -e "require 'yaml';(YAML.load_file('$app_root/.release')['config_vars'] || {}).each{|k,v| puts \"#{k}=#{v}\"}" > $app_root/.profile.d/config_vars

cat << EOF > "${HOME}/start"
#!/bin/bash
export HOME=${app_root}
export ORDERS_IN=${app_root}

export ORDERS_NAME="$(basename $(dirname $orders))"

#############################################################
# New Relic - May be overridden in HQ .starphleet file
# Set New_Relic env vars befor sourcing tools script
# This allows overriding in HQ .starphleet file
# Finally add SHIP_NAME to Labels - Not available until after sourcing tools script
#############################################################
# Load User Data vars if they exist, to get Environment

if [ -f /etc/starphleet.d/user_data_env ]; then
  source /etc/starphleet.d/user_data_env 
fi

export NEW_RELIC_LICENSE_KEY=bd51b51debfc060bba7f64f71e6dc22a41a6c3d6
export NEW_RELIC_NO_CONFIG_FILE=true

# Set app name with environment appended, if available
if [ -z RUNNING_ON ]; THEN
  export NEW_RELIC_APP_NAME="${ORDERS_NAME},services"
else
  export NEW_RELIC_APP_NAME="${ORDERS_NAME}-${RUNNING_ON},services-${RUNNING_ON}"
fi


source /usr/bin/tools

export NEW_RELIC_LABELS="${NEW_RELIC_LABELS};SHIP:$SHIP_NAME"


container_environment ${app_root} ${orders}
if [[ -f Procfile ]]; then
    ruby -e "require 'yaml';puts YAML.load_file('Procfile')['\$1']" | bash
else
    ruby -e "require 'yaml';puts (YAML.load_file('.release')['default_process_types'] || {})['\$1']" | bash
fi
EOF


chmod +x "${HOME}/start"
